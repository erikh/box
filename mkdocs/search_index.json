{
    "docs": [
        {
            "location": "/", 
            "text": "Box Features\n\n\nBox is a utility for the building of docker images. Through use of mruby,\nwe provide additional flexibility over the vanilla \ndocker build\n command by\nadding control structures and basic predicates. We also add new verbs that\nallow new actions, such as flattening and tagging images.\n\n\nSome features that differentiate it from \ndocker build\n:\n\n\n\n\nUnique general features:\n\n\nmruby syntax\n\n\nfiltering of keywords to secure builds\n\n\nSimultaneous build of multiple projects\n\n\nRead-Eval-Print-Loop (Shell) mode\n\n\n\n\n\n\nIn the build plan itself:\n\n\nTagging\n\n\nFlattening\n\n\nDebug mode (drop to a shell in the middle of a plan run and inspect your container)\n\n\nRuby block methods for \nuser\n (\nwith_user\n) and \nworkdir\n (\ninside\n) allow\n  you to scope \ncopy\n and \nrun\n operations for a more obvious build plan.\n\n\n\n\n\n\n\n\nGetting Box\n\n\nDownload a Release\n\n\nInstallation\n\n\nQuick Install: \ncurl -sSL box-builder.sh | sudo bash\n\n\nOr \ndownload a release\n: Just\n\ngunzip\n the downloaded file and put it in your path:\n\n\n$ gunzip box.$(uname -s).gz\n$ chmod 755 box.$(uname -s)\n$ sudo mv box.$(uname -s) /usr/local/bin/box\n\n\n\n\nAlternatively, we have a \nhomebrew tap\n\nand debian and redhat packages on the \nreleases page\n.\n\n\nBuild Plans\n\n\nBuild Plans power Box and are the core of its functionality. This\ndocument describes how you can power box by writing build plans, and\nwhat techniques to use while writing them.\n\n\nBox Build Plans are Programs\n\n\nExploit this! Use functions! Set variables and constants!\n\n\nrun this plan with:\n\n\nGOLANG_VERSION=1.7.5 box [plan file]\n\n\n\n\nIf a plan name is not specified it will default to \nbox.rb\n.\n\n\nfrom \nubuntu\n\n\n# this function will create a new layer running the command inside the\n# function, installing the required package.\ndef install_package(pkg)\n  run \napt-get install '#{pkg}' -y\n\nend\n\nrun \napt-get update\n\ninstall_package \ncurl\n # `run \napt-get install curl -y\n`\n\n# get the local environment's setting for GOLANG_VERSION, and set it here:\ngo_version = getenv(\nGOLANG_VERSION\n)\nrun %Q[curl -sSL \\\n    https://storage.googleapis.com/golang/go#{go_version}.linux-amd64.tar.gz \\\n    | tar -xvz -C /usr/local]\n\n\n\n\nPowered by mruby\n\n\nBox uses the \nmruby programming language\n. It does\nthis to get a solid language syntax, functions, variables and more.\nHowever, it is not a fully featured Ruby such as MRI and contains almost\nzero standard library functionality, allowing for only the basic types,\nand no I/O operations outside of the box DSL are permitted.\n\n\nYou can however:\n\n\n\n\nDefine classes, functions, variables and constants\n\n\nAccess the environment through the\n  \ngetenv\n box function (which is also\n  \nomittable\n if you don't want people to use\n  it)\n\n\nRetrieve the contents of container files with \nread\n\n\nimport\n libraries (also written in\n  mruby) to re-use common build plan components.\n\n\n\n\nTagging and Image Editing\n\n\nYou can tag images mid-plan to create multiple images, each subsets (or\nsupersets, depending on how you look at it) of each other.\n\n\nAdditionally, you can use functions like\n\nafter\n, \nskip\n,\nand \nflatten\n to manipulate images in ways\nyou may not have considered:\n\n\nfrom :ubuntu\nskip do\n  run \napt-get update\n\n  run \napt-get install curl -y\n\n  run \ncurl -sSL -O https://github.com/erikh/box/releases/download/v0.4.2/box_0.4.2_amd64.deb\n\n  tag :downloaded\nend\n\nrun \ndpkg -i box*.deb\n\nafter do\n  flatten\n  tag :installed\nend\n\n\n\n\nBecause the tag is processed after the final edits occur, tag\n\ninstalled\n will not contain the update manifests, \ncurl\n, or the\n\n.deb\n. Tag \ndownloaded\n will, though (but will also not contain the\ninstalled package).\n\n\nThe Debugger\n\n\ndebug\n is a really powerful tool for\nestablishing a breakpoint in your build plan where you can investigate\nyour container.\n\n\nJust add a line:\n\n\ndebug\n\n\n\n\nAnd as soon as it is reached you will see a shell appear in your\nconsole.\n\n\nVerb Properties\n\n\ncopy\n, \nrun\n, and\nother support properties to modify their behavior. You should check out\nwhat you can do in the docs, but here are a few examples.\n\n\n# `output: false` runs vim without attaching to the TTY, allowing you to run this\n# command in a logging environment as well as a terminal one\nrun \nvim +PluginInstall -c 'set nomore' +qall\n, output: false\n\n# `ignore_list` takes an array of string patterns to ignore from the\n# file list.\ncopy \n*\n, \n.\n, ignore_list: %w[foo bar]\n\n\n\n\nExperiment with the REPL\n\n\nThe REPL is a line interpreter that immediately gives you feedback on\nany given statement, allowing you to build an image interactively.\n\n\nWorks great with \ndebug\n!\n\n\nLaunch with \nbox repl\n.\n\n\nParallel Building\n\n\nbox multi\n can build several plans at once. Just supply multiple\nfilenames!\n\n\nNote that multi-builds do not return the output of run statements, largely\nbecause there would be a lot of noise in parallel execution.", 
            "title": "Intro"
        }, 
        {
            "location": "/#box-features", 
            "text": "Box is a utility for the building of docker images. Through use of mruby,\nwe provide additional flexibility over the vanilla  docker build  command by\nadding control structures and basic predicates. We also add new verbs that\nallow new actions, such as flattening and tagging images.  Some features that differentiate it from  docker build :   Unique general features:  mruby syntax  filtering of keywords to secure builds  Simultaneous build of multiple projects  Read-Eval-Print-Loop (Shell) mode    In the build plan itself:  Tagging  Flattening  Debug mode (drop to a shell in the middle of a plan run and inspect your container)  Ruby block methods for  user  ( with_user ) and  workdir  ( inside ) allow\n  you to scope  copy  and  run  operations for a more obvious build plan.", 
            "title": "Box Features"
        }, 
        {
            "location": "/#getting-box", 
            "text": "Download a Release", 
            "title": "Getting Box"
        }, 
        {
            "location": "/#installation", 
            "text": "Quick Install:  curl -sSL box-builder.sh | sudo bash  Or  download a release : Just gunzip  the downloaded file and put it in your path:  $ gunzip box.$(uname -s).gz\n$ chmod 755 box.$(uname -s)\n$ sudo mv box.$(uname -s) /usr/local/bin/box  Alternatively, we have a  homebrew tap \nand debian and redhat packages on the  releases page .", 
            "title": "Installation"
        }, 
        {
            "location": "/#build-plans", 
            "text": "Build Plans power Box and are the core of its functionality. This\ndocument describes how you can power box by writing build plans, and\nwhat techniques to use while writing them.", 
            "title": "Build Plans"
        }, 
        {
            "location": "/#box-build-plans-are-programs", 
            "text": "Exploit this! Use functions! Set variables and constants!  run this plan with:  GOLANG_VERSION=1.7.5 box [plan file]  If a plan name is not specified it will default to  box.rb .  from  ubuntu \n\n# this function will create a new layer running the command inside the\n# function, installing the required package.\ndef install_package(pkg)\n  run  apt-get install '#{pkg}' -y \nend\n\nrun  apt-get update \ninstall_package  curl  # `run  apt-get install curl -y `\n\n# get the local environment's setting for GOLANG_VERSION, and set it here:\ngo_version = getenv( GOLANG_VERSION )\nrun %Q[curl -sSL \\\n    https://storage.googleapis.com/golang/go#{go_version}.linux-amd64.tar.gz \\\n    | tar -xvz -C /usr/local]", 
            "title": "Box Build Plans are Programs"
        }, 
        {
            "location": "/#powered-by-mruby", 
            "text": "Box uses the  mruby programming language . It does\nthis to get a solid language syntax, functions, variables and more.\nHowever, it is not a fully featured Ruby such as MRI and contains almost\nzero standard library functionality, allowing for only the basic types,\nand no I/O operations outside of the box DSL are permitted.  You can however:   Define classes, functions, variables and constants  Access the environment through the\n   getenv  box function (which is also\n   omittable  if you don't want people to use\n  it)  Retrieve the contents of container files with  read  import  libraries (also written in\n  mruby) to re-use common build plan components.", 
            "title": "Powered by mruby"
        }, 
        {
            "location": "/#tagging-and-image-editing", 
            "text": "You can tag images mid-plan to create multiple images, each subsets (or\nsupersets, depending on how you look at it) of each other.  Additionally, you can use functions like after ,  skip ,\nand  flatten  to manipulate images in ways\nyou may not have considered:  from :ubuntu\nskip do\n  run  apt-get update \n  run  apt-get install curl -y \n  run  curl -sSL -O https://github.com/erikh/box/releases/download/v0.4.2/box_0.4.2_amd64.deb \n  tag :downloaded\nend\n\nrun  dpkg -i box*.deb \nafter do\n  flatten\n  tag :installed\nend  Because the tag is processed after the final edits occur, tag installed  will not contain the update manifests,  curl , or the .deb . Tag  downloaded  will, though (but will also not contain the\ninstalled package).", 
            "title": "Tagging and Image Editing"
        }, 
        {
            "location": "/#the-debugger", 
            "text": "debug  is a really powerful tool for\nestablishing a breakpoint in your build plan where you can investigate\nyour container.  Just add a line:  debug  And as soon as it is reached you will see a shell appear in your\nconsole.", 
            "title": "The Debugger"
        }, 
        {
            "location": "/#verb-properties", 
            "text": "copy ,  run , and\nother support properties to modify their behavior. You should check out\nwhat you can do in the docs, but here are a few examples.  # `output: false` runs vim without attaching to the TTY, allowing you to run this\n# command in a logging environment as well as a terminal one\nrun  vim +PluginInstall -c 'set nomore' +qall , output: false\n\n# `ignore_list` takes an array of string patterns to ignore from the\n# file list.\ncopy  * ,  . , ignore_list: %w[foo bar]", 
            "title": "Verb Properties"
        }, 
        {
            "location": "/#experiment-with-the-repl", 
            "text": "The REPL is a line interpreter that immediately gives you feedback on\nany given statement, allowing you to build an image interactively.  Works great with  debug !  Launch with  box repl .", 
            "title": "Experiment with the REPL"
        }, 
        {
            "location": "/#parallel-building", 
            "text": "box multi  can build several plans at once. Just supply multiple\nfilenames!  Note that multi-builds do not return the output of run statements, largely\nbecause there would be a lot of noise in parallel execution.", 
            "title": "Parallel Building"
        }, 
        {
            "location": "/usage/", 
            "text": "Usage\n\n\nUse the shell\n\n\nIf you want to try out box quickly, you can use the shell interface, AKA\nrepl (read-eval-print loop):\n\n\n$ box repl\n# or\n$ box shell\n\n\n\n\nThis video gives a quick demo of the shell:\n\n\n\n\n\nWith a Plan\n\n\nThe commandline tool \nbox\n accepts a file (your \"build plan\") as a commandline\nargument:\n\n\n$ box myplan.rb\n\n\n\n\nThe current working directory that Box runs in is very important, it is the\njumping-off point for most copy operations. If you run the \nbox-builder/box\n\ncontainer, you may wish to run it in this way:\n\n\n$ docker run -i \\\n  -v $PWD:$PWD \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -w $PWD \\\n  box-builder/box:latest myplan.rb\n\n\n\n\nFor additional flags and functionality, see the help:\n\n\n$ box --help\n\n\n\n\nWith Multiple Plans\n\n\nTo initiate multi-plan builds (where all builds are done at the same time) just\ninvoke \nbox multi\n and specify all the plans you want, e.g.:\n\n\n$ box multi *.rb\n\n\n\n\nWhich will build all the \n.rb\n files in the current dir.\n\n\nNote\n: it is important to use the \ntag\n verb to\navoid losing track of your images!\n\n\nMaking Box Plans\n\n\nBox plans are written in mruby, an embedded, smaller variant of ruby. If you\nare new to ruby, here is a tutorial that only \ncovers the basics\n\nYou will not need to be an advanced ruby user to leverage Box.\n\n\nBox plan terms are either functions or verbs.\n\n\nVerbs typically create a layer and are meant to run at the top level of the\nplan; they are not intended to return a sane value other than success/fail.\nOperations like \nrun\n and \ncopy\n fit into the \"verb\" category. These are very\nsimilar to the verbs you'd find in \ndocker build\n.\n\n\nFunctions are unique to Box and allow you to pass data both from the image into\nthe build system and pass it to other calls, or just print it out for later\nuse. Functions like \ngetuid\n exist to retrieve the UID of a user as the\ncontainer sees it, for the purposes of using it for future operations.\n\n\nPlease take a look at our \nverbs reference\n and \nfunctions\nreference\n for more information.\n\n\nExample Box Plan\n\n\nHere's a basic example that downloads the newest (1.7.3) version of golang with\ncurl and unpacks it. If you set an environment variable called\n\nGO_VERSION\n, it will use that version instead.\n\n\nfrom \ndebian\n\n\nrun \napt-get update\n\nrun \napt-get install curl -y\n\n\ngo_version = getenv(\nGO_VERSION\n)\n\nif go_version.empty?\n  go_version = \n1.7.3\n\nend\n\nurl = \nhttps://storage.googleapis.com/golang/go#{go_version}.linux-amd64.tar.gz\n\n\nrun \ncurl -sSL '#{url}' | tar -xvz -C /usr/local\n\n\n\n\n\nIgnoring files\n\n\nJust like Docker, if a \n.dockerignore\n file exists, the patterns, filenames,\nand directories specified in this file will be ignored from all copy operations.\n\n\nThe \ncopy\n verb also has additional functionality to\nscope ignore rules down to specific copy statements.\n\n\nThe Build Cache\n\n\nThe build cache is enabled by default. It is not an exact cache but constructs\nthe layer graph in a non-standard way using docker's image Comment field,\npopulating it with sums and command instructions in a very similar way that\n\ndocker build\n does.\n\n\nIf you find the behavior surprising, you can turn it off:\n\n\n$ box --no-cache myplan.rb\n\n\n\n\nExample Box Plan (advanced version)\n\n\nThis is the Box plan we use to build Box itself. It uses many of its\nfeatures. Be sure to check the \nverbs\n to\nrefer to different constructs used in the file.\n\n\nYou can find the latest version of it\n\nhere\n too.\n\n\nfrom \ngolang\n\n\nskip do\n  DOCKER_VERSION = \n1.12.4\n\n\n  PACKAGES = %w[\n    build-essential\n    g++\n    git\n    wget\n    curl\n    ruby\n    bison\n    flex\n    iptables\n    psmisc\n    python-pip\n  ]\n\n  workdir \n/\n\n\n  qq = getenv(\nCI_BUILD\n) != \n ? \n-qq\n : \n\n\n  run \napt-get update #{qq}\n\n  run \napt-get install -y #{qq} #{PACKAGES.join(\n \n)}\n\n  env \nGOPATH\n =\n \n/go\n\n\n  docker_path = \ndocker-#{DOCKER_VERSION}.tgz\n\n  run \nwget -q https://get.docker.com/builds/Linux/x86_64/#{docker_path}\n\n  run \ntar -xpf #{docker_path} --strip-components=1 -C /usr/bin/\n\n  run \nrm #{docker_path}\n\n  copy \ndind\n, \n/dind\n\n\n  run \npip -q install mkdocs mkdocs-bootswatch\n\n\n  copy \n.\n, \n/go/src/github.com/box-builder/box\n\n  run \ncd /go/src/github.com/box-builder/box \n make clean install\n\n\n  workdir \n/go/src/github.com/box-builder/box\n\n  set_exec entrypoint: [\n/dind\n], cmd: [\nmake\n, \ndocker-test\n]\n  tag \nbox-test\n\nend\n\nrun \nmv /go/bin/box /box\n\nset_exec entrypoint: [\n/box\n], cmd: []", 
            "title": "Usage"
        }, 
        {
            "location": "/usage/#usage", 
            "text": "", 
            "title": "Usage"
        }, 
        {
            "location": "/usage/#use-the-shell", 
            "text": "If you want to try out box quickly, you can use the shell interface, AKA\nrepl (read-eval-print loop):  $ box repl\n# or\n$ box shell  This video gives a quick demo of the shell:", 
            "title": "Use the shell"
        }, 
        {
            "location": "/usage/#with-a-plan", 
            "text": "The commandline tool  box  accepts a file (your \"build plan\") as a commandline\nargument:  $ box myplan.rb  The current working directory that Box runs in is very important, it is the\njumping-off point for most copy operations. If you run the  box-builder/box \ncontainer, you may wish to run it in this way:  $ docker run -i \\\n  -v $PWD:$PWD \\\n  -v /var/run/docker.sock:/var/run/docker.sock \\\n  -w $PWD \\\n  box-builder/box:latest myplan.rb  For additional flags and functionality, see the help:  $ box --help", 
            "title": "With a Plan"
        }, 
        {
            "location": "/usage/#with-multiple-plans", 
            "text": "To initiate multi-plan builds (where all builds are done at the same time) just\ninvoke  box multi  and specify all the plans you want, e.g.:  $ box multi *.rb  Which will build all the  .rb  files in the current dir.  Note : it is important to use the  tag  verb to\navoid losing track of your images!", 
            "title": "With Multiple Plans"
        }, 
        {
            "location": "/usage/#making-box-plans", 
            "text": "Box plans are written in mruby, an embedded, smaller variant of ruby. If you\nare new to ruby, here is a tutorial that only  covers the basics \nYou will not need to be an advanced ruby user to leverage Box.  Box plan terms are either functions or verbs.  Verbs typically create a layer and are meant to run at the top level of the\nplan; they are not intended to return a sane value other than success/fail.\nOperations like  run  and  copy  fit into the \"verb\" category. These are very\nsimilar to the verbs you'd find in  docker build .  Functions are unique to Box and allow you to pass data both from the image into\nthe build system and pass it to other calls, or just print it out for later\nuse. Functions like  getuid  exist to retrieve the UID of a user as the\ncontainer sees it, for the purposes of using it for future operations.  Please take a look at our  verbs reference  and  functions\nreference  for more information.", 
            "title": "Making Box Plans"
        }, 
        {
            "location": "/usage/#example-box-plan", 
            "text": "Here's a basic example that downloads the newest (1.7.3) version of golang with\ncurl and unpacks it. If you set an environment variable called GO_VERSION , it will use that version instead.  from  debian \n\nrun  apt-get update \nrun  apt-get install curl -y \n\ngo_version = getenv( GO_VERSION )\n\nif go_version.empty?\n  go_version =  1.7.3 \nend\n\nurl =  https://storage.googleapis.com/golang/go#{go_version}.linux-amd64.tar.gz \n\nrun  curl -sSL '#{url}' | tar -xvz -C /usr/local", 
            "title": "Example Box Plan"
        }, 
        {
            "location": "/usage/#ignoring-files", 
            "text": "Just like Docker, if a  .dockerignore  file exists, the patterns, filenames,\nand directories specified in this file will be ignored from all copy operations.  The  copy  verb also has additional functionality to\nscope ignore rules down to specific copy statements.", 
            "title": "Ignoring files"
        }, 
        {
            "location": "/usage/#the-build-cache", 
            "text": "The build cache is enabled by default. It is not an exact cache but constructs\nthe layer graph in a non-standard way using docker's image Comment field,\npopulating it with sums and command instructions in a very similar way that docker build  does.  If you find the behavior surprising, you can turn it off:  $ box --no-cache myplan.rb", 
            "title": "The Build Cache"
        }, 
        {
            "location": "/usage/#example-box-plan-advanced-version", 
            "text": "This is the Box plan we use to build Box itself. It uses many of its\nfeatures. Be sure to check the  verbs  to\nrefer to different constructs used in the file.  You can find the latest version of it here  too.  from  golang \n\nskip do\n  DOCKER_VERSION =  1.12.4 \n\n  PACKAGES = %w[\n    build-essential\n    g++\n    git\n    wget\n    curl\n    ruby\n    bison\n    flex\n    iptables\n    psmisc\n    python-pip\n  ]\n\n  workdir  / \n\n  qq = getenv( CI_BUILD ) !=   ?  -qq  :  \n\n  run  apt-get update #{qq} \n  run  apt-get install -y #{qq} #{PACKAGES.join(   )} \n  env  GOPATH  =   /go \n\n  docker_path =  docker-#{DOCKER_VERSION}.tgz \n  run  wget -q https://get.docker.com/builds/Linux/x86_64/#{docker_path} \n  run  tar -xpf #{docker_path} --strip-components=1 -C /usr/bin/ \n  run  rm #{docker_path} \n  copy  dind ,  /dind \n\n  run  pip -q install mkdocs mkdocs-bootswatch \n\n  copy  . ,  /go/src/github.com/box-builder/box \n  run  cd /go/src/github.com/box-builder/box   make clean install \n\n  workdir  /go/src/github.com/box-builder/box \n  set_exec entrypoint: [ /dind ], cmd: [ make ,  docker-test ]\n  tag  box-test \nend\n\nrun  mv /go/bin/box /box \nset_exec entrypoint: [ /box ], cmd: []", 
            "title": "Example Box Plan (advanced version)"
        }, 
        {
            "location": "/installation/", 
            "text": "Getting Box\n\n\nDownload a Release\n\n\nInstallation\n\n\nJust \ngunzip\n the downloaded file and put it in your path:\n\n\n$ gunzip box.$(uname -s).gz\n$ chmod 755 box.$(uname -s)\n$ sudo mv box.$(uname -s) /usr/local/bin/box\n\n\n\n\nAlternatively, we have a \nhomebrew tap\n\nand debian and redhat packages on the \nreleases page\n.\n\n\nInvocation\n\n\nUse the shell\n\n\nIf you want to try out box quickly, you can use the shell interface, AKA\nrepl (read-eval-print loop):\n\n\n$ box repl\n# or\n$ box shell\n\n\n\n\nThis video gives a quick demo of the shell:", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#getting-box", 
            "text": "Download a Release", 
            "title": "Getting Box"
        }, 
        {
            "location": "/installation/#installation", 
            "text": "Just  gunzip  the downloaded file and put it in your path:  $ gunzip box.$(uname -s).gz\n$ chmod 755 box.$(uname -s)\n$ sudo mv box.$(uname -s) /usr/local/bin/box  Alternatively, we have a  homebrew tap \nand debian and redhat packages on the  releases page .", 
            "title": "Installation"
        }, 
        {
            "location": "/installation/#invocation", 
            "text": "", 
            "title": "Invocation"
        }, 
        {
            "location": "/installation/#use-the-shell", 
            "text": "If you want to try out box quickly, you can use the shell interface, AKA\nrepl (read-eval-print loop):  $ box repl\n# or\n$ box shell  This video gives a quick demo of the shell:", 
            "title": "Use the shell"
        }, 
        {
            "location": "/user-guide/cli/", 
            "text": "Command-Line Options in box alter behavior of box for its runtime.  Using these\noptions shape your build and suit it for use in many group environments.\n\n\nIn the documentation below, each long option is in the heading with the short\noption (if any) in parentheses.\n\n\nREPL Mode\n\n\nbox repl\n or \nbox shell\n will initiate REPL mode, a line-by-line interpreter\nwith instant results.\n\n\nMulti Mode\n\n\nbox multi\n will initiate multi-mode, which invokes multiple builds at the same\ntime.\n\n\n--help (-h) and --version (-v)\n\n\nShow the help and version respectively.\n\n\n--no-cache (-n)\n\n\nTurn caching off, this forces a rebuild of all build plan steps. Note that\nthis won't re-pull any pulled images.\n\n\nExample:\n\n\n$ box -n plan.rb\n\n\n\n\n--omit (-o)\n\n\nOmit a function or verb from the DSL. This removes all functionality of a\nspecific mruby verb or function and causes a syntax error if encountered.  This\nrestricts certain operations in builds for teams or unprivileged scenarios.\n\n\nExample:\n\n\n$ cat \nplan.rb \nEOF\nfrom 'debian'\ntag 'mydebian'\nEOF\n# boom - missing keyword or function from ruby\n$ box -o tag plan.rb\n\n\n\n\n--tag (-t)\n\n\nTag the last generated image with the provided value. If the tag fails, the\nbuild won't fail, but instead be untagged. However, box still exits\nnon-zero to indicate the tag failed.\n\n\nExample:\n\n\n# starts a build with debian and retags the result as 'mydebian'\necho \nfrom 'debian'\n | box -t mydebian\n\n\n\n\n--no-tty\n\n\nForcibly turn all tty operation/propagation off for this run. This will cause\nmany programs to behave different specifically in \nrun\n statements, and the\n\npull\n animations for downloading will not be provided.\n\n\nNo TTY mode is the default when unix pipes are involved.\n\n\n--force-tty\n\n\nForce the TTY on even if it is off for some reason.\n\n\nThe combination of \n--no-tty --force-tty\n is to force the tty.", 
            "title": "Command-Line Options"
        }, 
        {
            "location": "/user-guide/cli/#repl-mode", 
            "text": "box repl  or  box shell  will initiate REPL mode, a line-by-line interpreter\nwith instant results.", 
            "title": "REPL Mode"
        }, 
        {
            "location": "/user-guide/cli/#multi-mode", 
            "text": "box multi  will initiate multi-mode, which invokes multiple builds at the same\ntime.", 
            "title": "Multi Mode"
        }, 
        {
            "location": "/user-guide/cli/#-help-h-and-version-v", 
            "text": "Show the help and version respectively.", 
            "title": "--help (-h) and --version (-v)"
        }, 
        {
            "location": "/user-guide/cli/#-no-cache-n", 
            "text": "Turn caching off, this forces a rebuild of all build plan steps. Note that\nthis won't re-pull any pulled images.  Example:  $ box -n plan.rb", 
            "title": "--no-cache (-n)"
        }, 
        {
            "location": "/user-guide/cli/#-omit-o", 
            "text": "Omit a function or verb from the DSL. This removes all functionality of a\nspecific mruby verb or function and causes a syntax error if encountered.  This\nrestricts certain operations in builds for teams or unprivileged scenarios.  Example:  $ cat  plan.rb  EOF\nfrom 'debian'\ntag 'mydebian'\nEOF\n# boom - missing keyword or function from ruby\n$ box -o tag plan.rb", 
            "title": "--omit (-o)"
        }, 
        {
            "location": "/user-guide/cli/#-tag-t", 
            "text": "Tag the last generated image with the provided value. If the tag fails, the\nbuild won't fail, but instead be untagged. However, box still exits\nnon-zero to indicate the tag failed.  Example:  # starts a build with debian and retags the result as 'mydebian'\necho  from 'debian'  | box -t mydebian", 
            "title": "--tag (-t)"
        }, 
        {
            "location": "/user-guide/cli/#-no-tty", 
            "text": "Forcibly turn all tty operation/propagation off for this run. This will cause\nmany programs to behave different specifically in  run  statements, and the pull  animations for downloading will not be provided.  No TTY mode is the default when unix pipes are involved.", 
            "title": "--no-tty"
        }, 
        {
            "location": "/user-guide/cli/#-force-tty", 
            "text": "Force the TTY on even if it is off for some reason.  The combination of  --no-tty --force-tty  is to force the tty.", 
            "title": "--force-tty"
        }, 
        {
            "location": "/user-guide/verbs/", 
            "text": "Verbs take action on a container and usually create a layer. Some commands can\nbe used to move data into and out of containers, or set properties and run\ncommands.\n\n\nlabel\n\n\nlabel\n creates a label inside the image. It will append any labels that are\nspecified in each label command, for example, if you were to:\n\n\nlabel foo: \nbar\n\nlabel quux: \nbaz\n\n\n\n\n\nIf you were to \ndocker inspect\n this, your ending labels would be:\n\n\n{\n  \nfoo\n: \nbar\n,\n  \nquux\n: \nbaz\n\n}\n\n\n\n\nYou can also do this all as one label:\n\n\nlabel foo: \nbar\n, quux: \nbaz\n\n\n\n\n\nOr if you'd like, store them in a variable for a final commit at the end:\n\n\nmylabels = { }\nmylabels[\nfoo\n] = \nbaz\n\n# ... some stuff that generates mydata\nmylabels[\nquux\n] = mydata\n\nlabel mylabels # voila!\n\n\n\n\ndebug\n\n\ndebug\n drops to a container's shell (bash by default, but an argument can be\nprovided to change this) at the current place in the build cycle when invoked.\nChanges to the container will be persisted through the rest of the run, and a\nlayer will be created.\n\n\nIf the shell exits non-zero, like \nrun\n it will abort the build.\n\n\nThere is currently no way to detach from a debug session. Close the shell\nand/or programs.\n\n\nExample:\n\n\nfrom \ndebian\n\ncopy \n.\n, \n/test\n\ndebug # verify all files landed in test like you expected them to\nrun \nchown -R erikh:erikh /test\n # this will run after you close the shell\n\n\n\n\nafter\n\n\nafter\n coordinates with \nskip\n to provide layer editing facilities. After the\nimage is recomposed, this hook will run. Great for tagging and flattening.\n\n\nExample:\n\n\nfrom \ndebian\n\n\n# after the skip layers are removed, run this hook.\nafter do\n  # tag the edited image as `dev`\n  tag \ndev\n\nend\n\nskip do\n  run \napt-get update -qq\n\nend\n\nrun \napt-get install tmux -y\n\n\n\n\n\nset_exec\n\n\nset_exec\n sets both the entrypoint and cmd at the same time.\n\n\nset_exec\n takes a dictionary consisting of two known elements as symbols:\nentrypoint and cmd. They each take a string array which is then propagated\nto the respective properties in the container's configuration.\n\n\nThis command does not modify the entrypoint or cmd for \nrun\n operations.\n\n\nExample:\n\n\nfrom \ndebian\n\n# this sets the what will be run with `/bin/echo foo`\nset_exec entrypoint: [\n/bin/echo\n], cmd: [\nfoo\n]\n\n\n\n\nworkdir\n\n\nworkdir sets the working directory in the docker environment. It sets this\nthroughout the image creation; all run/copy statements will respect this\nvalue. If you wish to break out or work within it further, look at the\n\ninside\n call.\n\n\nThe workdir, if left empty by either the parent in \nfrom\n or from no\ninteraction from the plan, is set to \n/\n to avoid inheriting accidentally from\nthe parent image.\n\n\nExample:\n\n\nfrom \ndebian\n\n# each container that runs this image without the `-w` flag will start as\n# `/test` for the current working directory.\nworkdir '/test'\n\n\n\n\nuser\n\n\nuser sets the username this container will use by default. It also affects\nfollowing run statements (but not copy, which always copies as root\ncurrently). If you wish to switch to a user temporarily, consider using\n\nwith_user\n.\n\n\nAn empty user is always set to \nroot\n in the final image.\n\n\nExample:\n\n\nfrom \ndebian\n\n# all containers started with this image will use user `foo`\n# %q[] just means, \nquote this as a string without interpolation\n\nuser %q[foo]\n\n\n\n\nflatten\n\n\nflatten requires no argumemnts and flattens all layers and commits a new\nlayer. This is useful for reducing the size of images or making them easier\nto distribute.\n\n\nNOTE: flattening will always bust the build cache.\n\n\nNOTE: flattening requires downloading the image and re-uploading it. This\ncan take a lot of time over remote connections and is not advised.\n\n\nExample:\n\n\nfrom \ndebian\n\n# create some layers\nrun \ntrue\n\ncopy \n.\n, \n/test\n\nflatten # image is shrunk to one layer here\ntag \nerikh/test\n\n\n\n\n\ntag\n\n\ntag tags an image within the docker daemon, named after the string provided.\nIt must be a valid tag name.\n\n\nExample:\n\n\nfrom \ndebian\n\nrun \ntrue\n # create a layer\ntag \nerikh/true\n # tag the latest image as \nerikh/true\n\n\n\n\n\nentrypoint\n\n\nentrypoint sets the entrypoint for the image at runtime. It will not be\nused for run invocations.\n\n\nExample:\n\n\nfrom \ndebian\n\n# if you pass nil or an empty array, it will clear any inherited cmd from the debian image.\nentrypoint []\nentrypoint %w[/bin/echo -e] # arrays also work\nentrypoint \n/bin/echo\n      # all `docker run` commands will be preceded by this\ncmd \nfoo\n                   # this will equate to `/bin/echo foo`\n\n\n\n\nfrom\n\n\nfrom sets the initial image and if necessary, pulls it from the registry. It\nalso sets the initial layer and must be called before several operations.\n\n\nUsing \nfrom\n overwrites all container configuration, including \nworkdir\n,\n\nuser\n, \nenv\n, \ncmd\n, and \nentrypoint\n.\n\n\nIt is expected that \nfrom\n is called first in a build plan.\n\n\nIf \nfrom :scratch\n is provided, the build plan will start out with no files and\nno configuration. You will want to use \ncopy\n, \nset_exec\n, etc to configure\nyour container image.\n\n\nExample:\n\n\nfrom \ndebian\n\n\n\n\n\nor other images with full tags:\n\n\nfrom \nceph/rbd:latest\n\n\n\n\n\nor fully qualified image IDs.\n\n\n# sha256s are longer than this normally.\nfrom \nsha256:deadbeefcafebabeaddedbeef\n\n\n\n\n\nfrom :scratch\n:\n\n\nfrom :scratch\ncopy \nbox\n, \n/\n\nentrypoint \n/box\n\n\n\n\n\nrun\n\n\nrun runs a command provided as a string, and saves the layer.\n\n\nIt respects user and workdir, but not entrypoint and command. It does this\nso it can respect the values provided in the plan instead of what was\nintended for the final image.\n\n\nOptions:\n\n\n\n\noutput\n: supply \nfalse\n to omit output from the plan run.\n\n\n\n\nCache keys are generated based on the command name, so to be certain your\ncommand is run in the event of it hitting cache, run box with NO_CACHE=1.\n\n\nExamples:\n\n\nCreate a file called \n/bar\n inside the container, then chown it to nobody. Run\ncommands don't need a lot of \n because you can trivially flatten the layers.\n\n\nRun does not accept the exec-form from docker's RUN equivalent. Everything RUN\nprocesses goes through \n/bin/sh -c\n.\n\n\nfrom \ndebian\n\nrun \necho foo \n/bar\n\nrun \nchown nobody:nogroup /bar\n\n\n\n\n\nRun in the context of a specific user or workdir. This allows us to finely\ncontrol our run invocations and further processing after the container image\nhas been run.\n\n\nfrom \ndebian\n\n\nwith_user \nnobody\n do # just the commands inside this block will run as `nobody`\n  run \necho foo \n/tmp/bar\n\nend\n\n# notice how we are still root\nrun \nuseradd -s /bin/sh -m -d /home/erikh erikh\n\n\n# all commands from here on will run as `erikh`, overridden only by `with_user`\n# and other `user` calls.\nuser \nerikh\n\nrun \necho foo \n/tmp/erikh-file\n\n\n# set the workdir temporarily for the commands within the block.\n# this will create /tmp/another-file-in-tmp.\ninside \n/tmp\n do\n  run \necho foo \nanother-file-in-tmp\n\nend\n\n# this behaves exactly like user, just setting the default cwd instead:\n# creates /tmp/yet-another-file\nworkdir \n/tmp\n\nrun \necho foo \nyet-another-file\n\n\n# will not display anything\nrun \nls -l /\n, output: false\n\n\n\n\nwith_user\n\n\nwith_user\n, when provided with a string username and block invokes commands\nwithin the user's login context. Unfortunately, copy does not respect this\nyet. It does not affect the final image.\n\n\nExample:\n\n\nfrom \ndebian\n\n\nwith_user \nnobody\n do\n  run \nwhoami\n # i am nobody!\nend\n\n\n\n\ninside\n\n\ninside, when provided with a directory name string and block, invokes\ncommands within the context of the working directory being set to the\nstring.\n\n\nIt will affect the final image if a file-modification event occurs inside a\ndirectory which has been specified but not created manually yet. This is a side\neffect of the docker engine's relationship to how we use \nworkdir\n directives\nwithin docker itself. \nDocker will create any workdir that does not exist when\na build container is started.\n\n\nExample:\n\n\nfrom \ndebian\n\n\ninside \n/dev\n do\n  run \nmknod webscale c 1 3\n\nend\n\n\n\n\nWhen given a relative path, it assumes the workdir as well as any other\nadditional inside statements. For example:\n\n\nworkdir \n/etc\n\ninside \napt\n do # will travel into /etc/apt/\n  run \nrm sources.list\n\nend\n\n\n\n\nenv\n\n\nenv, when provided with a hash of string =\n string key/value combinations,\nwill set the environment in the image and future run invocations.\n\n\nExample:\n\n\nfrom \ndebian\n\n\nenv \nGOPATH\n =\n \n/go\n, \nPATH\n =\n \n/usr/bin:/bin\n\nenv GOPATH: \n/go\n, PATH: \n/usr/bin:/bin\n # equivalent if you prefer this syntax\n\n\n\n\ncmd\n\n\ncmd, when provided with a string will set the docker image's Cmd property,\nwhich are the arguments that follow the entrypoint (and are overridden when\nyou provide a command to \ndocker run\n). It does not affect run invocations.\n\n\nExample:\n\n\nfrom \ndebian\n\n# if you pass nil or an empty array, it will clear any inherited cmd from the debian image.\ncmd nil\n# You can also use arrays.\ncmd %w[ls -la]\n# This image will run `ls` in the workdir by default.\ncmd \nls\n\n\n\n\n\ncopy\n\n\ncopy copies files from the host to the container. It only works relative to\nthe current directory. The build cache is calculated by summing the tar\nresult of edited files. Since mtime is also considered, changes to that will\nalso bust the cache.\n\n\ncopy accepts globbing on the local side (LHS of arguments) according to\n\nthese rules\n. For example, it\nsupports \n*\n but not the zsh extended \n**\n syntax.\n\n\nParameters may be specified after the target directory; the following options\nare supported:\n\n\n\n\nignore_list\n: the provided array of file patterns will be ignored from the\n  copied product.\n\n\nignore_file\n: similar to \nignore_list\n, it will reap the values from the\n  filename specified.\n\n\n\n\nNOTE: copy will not overwrite directories with files, this will abort the run.\nIf you are trying to copy a file into a named directory, suffix it with \n/\n\nwhich will instruct it to put it into that directory instead of trying to\nreplace it with the file you're copying.\n\n\nNOTE: copy does not respect user permissions when the \nuser\n or \nwith_user\n\nmodifiers are applied. This will be fixed eventually.\n\n\nExample:\n\n\nfrom \ndebian\n\n\n# recursively copies everything the cwd to test, which is relative to the\n# workdir inside the container (`/` by default).\nworkdir \n/tmp\n, do\n  copy \n.\n, \n/test\n\nend\n\ncopy \na_file\n, \n/tmp/\n # example of not overwriting directories with files\ncopy \nfiles*\n, \n/var/lib\n # example of globbing\n\n# copy all files named `files*`, but ignore the ones that start with `files1*`.\ncopy \nfiles*\n, \n/var/lib\n, ignore_list: [\nfiles1*\n]", 
            "title": "Verbs"
        }, 
        {
            "location": "/user-guide/verbs/#label", 
            "text": "label  creates a label inside the image. It will append any labels that are\nspecified in each label command, for example, if you were to:  label foo:  bar \nlabel quux:  baz   If you were to  docker inspect  this, your ending labels would be:  {\n   foo :  bar ,\n   quux :  baz \n}  You can also do this all as one label:  label foo:  bar , quux:  baz   Or if you'd like, store them in a variable for a final commit at the end:  mylabels = { }\nmylabels[ foo ] =  baz \n# ... some stuff that generates mydata\nmylabels[ quux ] = mydata\n\nlabel mylabels # voila!", 
            "title": "label"
        }, 
        {
            "location": "/user-guide/verbs/#debug", 
            "text": "debug  drops to a container's shell (bash by default, but an argument can be\nprovided to change this) at the current place in the build cycle when invoked.\nChanges to the container will be persisted through the rest of the run, and a\nlayer will be created.  If the shell exits non-zero, like  run  it will abort the build.  There is currently no way to detach from a debug session. Close the shell\nand/or programs.  Example:  from  debian \ncopy  . ,  /test \ndebug # verify all files landed in test like you expected them to\nrun  chown -R erikh:erikh /test  # this will run after you close the shell", 
            "title": "debug"
        }, 
        {
            "location": "/user-guide/verbs/#after", 
            "text": "after  coordinates with  skip  to provide layer editing facilities. After the\nimage is recomposed, this hook will run. Great for tagging and flattening.  Example:  from  debian \n\n# after the skip layers are removed, run this hook.\nafter do\n  # tag the edited image as `dev`\n  tag  dev \nend\n\nskip do\n  run  apt-get update -qq \nend\n\nrun  apt-get install tmux -y", 
            "title": "after"
        }, 
        {
            "location": "/user-guide/verbs/#set95exec", 
            "text": "set_exec  sets both the entrypoint and cmd at the same time.  set_exec  takes a dictionary consisting of two known elements as symbols:\nentrypoint and cmd. They each take a string array which is then propagated\nto the respective properties in the container's configuration.  This command does not modify the entrypoint or cmd for  run  operations.  Example:  from  debian \n# this sets the what will be run with `/bin/echo foo`\nset_exec entrypoint: [ /bin/echo ], cmd: [ foo ]", 
            "title": "set_exec"
        }, 
        {
            "location": "/user-guide/verbs/#workdir", 
            "text": "workdir sets the working directory in the docker environment. It sets this\nthroughout the image creation; all run/copy statements will respect this\nvalue. If you wish to break out or work within it further, look at the inside  call.  The workdir, if left empty by either the parent in  from  or from no\ninteraction from the plan, is set to  /  to avoid inheriting accidentally from\nthe parent image.  Example:  from  debian \n# each container that runs this image without the `-w` flag will start as\n# `/test` for the current working directory.\nworkdir '/test'", 
            "title": "workdir"
        }, 
        {
            "location": "/user-guide/verbs/#user", 
            "text": "user sets the username this container will use by default. It also affects\nfollowing run statements (but not copy, which always copies as root\ncurrently). If you wish to switch to a user temporarily, consider using with_user .  An empty user is always set to  root  in the final image.  Example:  from  debian \n# all containers started with this image will use user `foo`\n# %q[] just means,  quote this as a string without interpolation \nuser %q[foo]", 
            "title": "user"
        }, 
        {
            "location": "/user-guide/verbs/#flatten", 
            "text": "flatten requires no argumemnts and flattens all layers and commits a new\nlayer. This is useful for reducing the size of images or making them easier\nto distribute.  NOTE: flattening will always bust the build cache.  NOTE: flattening requires downloading the image and re-uploading it. This\ncan take a lot of time over remote connections and is not advised.  Example:  from  debian \n# create some layers\nrun  true \ncopy  . ,  /test \nflatten # image is shrunk to one layer here\ntag  erikh/test", 
            "title": "flatten"
        }, 
        {
            "location": "/user-guide/verbs/#tag", 
            "text": "tag tags an image within the docker daemon, named after the string provided.\nIt must be a valid tag name.  Example:  from  debian \nrun  true  # create a layer\ntag  erikh/true  # tag the latest image as  erikh/true", 
            "title": "tag"
        }, 
        {
            "location": "/user-guide/verbs/#entrypoint", 
            "text": "entrypoint sets the entrypoint for the image at runtime. It will not be\nused for run invocations.  Example:  from  debian \n# if you pass nil or an empty array, it will clear any inherited cmd from the debian image.\nentrypoint []\nentrypoint %w[/bin/echo -e] # arrays also work\nentrypoint  /bin/echo       # all `docker run` commands will be preceded by this\ncmd  foo                    # this will equate to `/bin/echo foo`", 
            "title": "entrypoint"
        }, 
        {
            "location": "/user-guide/verbs/#from", 
            "text": "from sets the initial image and if necessary, pulls it from the registry. It\nalso sets the initial layer and must be called before several operations.  Using  from  overwrites all container configuration, including  workdir , user ,  env ,  cmd , and  entrypoint .  It is expected that  from  is called first in a build plan.  If  from :scratch  is provided, the build plan will start out with no files and\nno configuration. You will want to use  copy ,  set_exec , etc to configure\nyour container image.  Example:  from  debian   or other images with full tags:  from  ceph/rbd:latest   or fully qualified image IDs.  # sha256s are longer than this normally.\nfrom  sha256:deadbeefcafebabeaddedbeef   from :scratch :  from :scratch\ncopy  box ,  / \nentrypoint  /box", 
            "title": "from"
        }, 
        {
            "location": "/user-guide/verbs/#run", 
            "text": "run runs a command provided as a string, and saves the layer.  It respects user and workdir, but not entrypoint and command. It does this\nso it can respect the values provided in the plan instead of what was\nintended for the final image.  Options:   output : supply  false  to omit output from the plan run.   Cache keys are generated based on the command name, so to be certain your\ncommand is run in the event of it hitting cache, run box with NO_CACHE=1.  Examples:  Create a file called  /bar  inside the container, then chown it to nobody. Run\ncommands don't need a lot of   because you can trivially flatten the layers.  Run does not accept the exec-form from docker's RUN equivalent. Everything RUN\nprocesses goes through  /bin/sh -c .  from  debian \nrun  echo foo  /bar \nrun  chown nobody:nogroup /bar   Run in the context of a specific user or workdir. This allows us to finely\ncontrol our run invocations and further processing after the container image\nhas been run.  from  debian \n\nwith_user  nobody  do # just the commands inside this block will run as `nobody`\n  run  echo foo  /tmp/bar \nend\n\n# notice how we are still root\nrun  useradd -s /bin/sh -m -d /home/erikh erikh \n\n# all commands from here on will run as `erikh`, overridden only by `with_user`\n# and other `user` calls.\nuser  erikh \nrun  echo foo  /tmp/erikh-file \n\n# set the workdir temporarily for the commands within the block.\n# this will create /tmp/another-file-in-tmp.\ninside  /tmp  do\n  run  echo foo  another-file-in-tmp \nend\n\n# this behaves exactly like user, just setting the default cwd instead:\n# creates /tmp/yet-another-file\nworkdir  /tmp \nrun  echo foo  yet-another-file \n\n# will not display anything\nrun  ls -l / , output: false", 
            "title": "run"
        }, 
        {
            "location": "/user-guide/verbs/#with95user", 
            "text": "with_user , when provided with a string username and block invokes commands\nwithin the user's login context. Unfortunately, copy does not respect this\nyet. It does not affect the final image.  Example:  from  debian \n\nwith_user  nobody  do\n  run  whoami  # i am nobody!\nend", 
            "title": "with_user"
        }, 
        {
            "location": "/user-guide/verbs/#inside", 
            "text": "inside, when provided with a directory name string and block, invokes\ncommands within the context of the working directory being set to the\nstring.  It will affect the final image if a file-modification event occurs inside a\ndirectory which has been specified but not created manually yet. This is a side\neffect of the docker engine's relationship to how we use  workdir  directives\nwithin docker itself.  Docker will create any workdir that does not exist when\na build container is started.  Example:  from  debian \n\ninside  /dev  do\n  run  mknod webscale c 1 3 \nend  When given a relative path, it assumes the workdir as well as any other\nadditional inside statements. For example:  workdir  /etc \ninside  apt  do # will travel into /etc/apt/\n  run  rm sources.list \nend", 
            "title": "inside"
        }, 
        {
            "location": "/user-guide/verbs/#env", 
            "text": "env, when provided with a hash of string =  string key/value combinations,\nwill set the environment in the image and future run invocations.  Example:  from  debian \n\nenv  GOPATH  =   /go ,  PATH  =   /usr/bin:/bin \nenv GOPATH:  /go , PATH:  /usr/bin:/bin  # equivalent if you prefer this syntax", 
            "title": "env"
        }, 
        {
            "location": "/user-guide/verbs/#cmd", 
            "text": "cmd, when provided with a string will set the docker image's Cmd property,\nwhich are the arguments that follow the entrypoint (and are overridden when\nyou provide a command to  docker run ). It does not affect run invocations.  Example:  from  debian \n# if you pass nil or an empty array, it will clear any inherited cmd from the debian image.\ncmd nil\n# You can also use arrays.\ncmd %w[ls -la]\n# This image will run `ls` in the workdir by default.\ncmd  ls", 
            "title": "cmd"
        }, 
        {
            "location": "/user-guide/verbs/#copy", 
            "text": "copy copies files from the host to the container. It only works relative to\nthe current directory. The build cache is calculated by summing the tar\nresult of edited files. Since mtime is also considered, changes to that will\nalso bust the cache.  copy accepts globbing on the local side (LHS of arguments) according to these rules . For example, it\nsupports  *  but not the zsh extended  **  syntax.  Parameters may be specified after the target directory; the following options\nare supported:   ignore_list : the provided array of file patterns will be ignored from the\n  copied product.  ignore_file : similar to  ignore_list , it will reap the values from the\n  filename specified.   NOTE: copy will not overwrite directories with files, this will abort the run.\nIf you are trying to copy a file into a named directory, suffix it with  / \nwhich will instruct it to put it into that directory instead of trying to\nreplace it with the file you're copying.  NOTE: copy does not respect user permissions when the  user  or  with_user \nmodifiers are applied. This will be fixed eventually.  Example:  from  debian \n\n# recursively copies everything the cwd to test, which is relative to the\n# workdir inside the container (`/` by default).\nworkdir  /tmp , do\n  copy  . ,  /test \nend\n\ncopy  a_file ,  /tmp/  # example of not overwriting directories with files\ncopy  files* ,  /var/lib  # example of globbing\n\n# copy all files named `files*`, but ignore the ones that start with `files1*`.\ncopy  files* ,  /var/lib , ignore_list: [ files1* ]", 
            "title": "copy"
        }, 
        {
            "location": "/user-guide/functions/", 
            "text": "Functions in Box provide a data-passing mechanism for build instructions. For\nexample, you may wish to read the contents of a file from the container into\nyour build for further processing; the \nread\n function allows that.\n\n\nThese are the functions supported by Box.\n\n\nsave\n\n\nsave\n saves an image with parameters:\n\n\n\n\ntag\n: tag the image in the docker image store. This does not generate a\n  commit, like the \ntag\n verb does.\n\n\nfile\n: save the image to a file. The resulting file will be a bare tarball\n  with the image contents, suitable for \ndocker load\n.\n\n\ntype\n: Two options: \ndocker\n, and \noci\n.\n\n\n\n\nExample:\n\n\nTag an image with the name \"foo\":\n\n\nfrom \nubuntu\n\nsave tag: \nfoo\n\n\n\n\n\nSave the ubuntu image to file after updating it:\n\n\nfrom \nubuntu\n\nrun \napt-get update -qq \n apt-get dist-upgrade -y\n\nsave file: \nubuntu-with-update.tar\n\n\n\n\n\nskip\n\n\nskip skips all layers within its block in the final produced image, which may\nbe tagged with the \n-t\n commandline argument or modified in an \nafter\n clause.\n\n\nNote that any other tagging or references to images built will still be\navailable with full image contents, this only affects the final output image.\n\n\nWARNING\n: This command can cause extreme latency over TCP connections as it\nrebuilds images locally, which requires it to pull down and re-push any images.\nIt is strongly recommended you build on the host you wish to push from or use.\n\n\nExample:\n\n\nThis will import the \ndebian\n image, and run commands to install software\nvia \napt-get\n. Then it will remove the update process's layer's contents from\nthe image, removing caches and other dirt from the final image.\n\n\nfrom \ndebian\n\n\nskip do\n  run \napt-get update\n\nend\n\nrun \napt-get install tmux\n\n\n\n\n\nimport\n\n\nimport loads a ruby file, and then executes it as if it were a box plan. This\nis principally used to modularize build instructions between multiple builds.\n\n\nNote that this will load ruby files specified anywhere on the filesystem. Use\nat your own risk. You can provide the \n-o import\n option to omit this function\nfrom use.\n\n\nExample:\n\n\nFile A:\n\n\nfrom \ndebian\n\n\n\n\n\nFile B imports File A and builds on it:\n\n\nimport \nfile-a.rb\n\nrun \nls\n\n\n\n\n\ngetenv\n\n\ngetenv retrieves a value from the building environment (passed in as string)\nand returns a string with the value. If no value exists, an empty string is\nreturned.\n\n\nExample:\n\n\n# If you set IMAGE=ceph/rbd:latest in your environment, that would be pulled\n# via the `from` statement.\nfrom getenv(\nIMAGE\n)\n\n\n\n\nread\n\n\nread takes a filename as string, reads it from the latest image in the\nevaluation and returns its data. Yields an error if the file does not exist\nor from has not been called.\n\n\nread returns a string which may then be manipulated with normal string\nmanipulations in ruby.\n\n\nExample:\n\n\nfrom \ndebian\n\n# this gets the first username in your passwd file inside the debian image\nrun \necho #{read(\n/etc/passwd\n).split(\n\\n\n).first.split(\n:\n)[0]}\n\n\n\n\n\ngetuid\n\n\ngetuid, given a string username provides an integer response with the UID of\nthe user. This works by reading the /etc/passwd file in the image.\n\n\nYields an error if it cannot find the user or from has not been called.\n\n\nExample:\n\n\nfrom \ndebian\n\nrun \nuseradd -m -d /home/erikh -s /bin/sh erikh\n\nrun \nid #{getuid(\nerikh\n)}\n\n\n\n\n\ngetgid\n\n\ngetgid, given a string group name provides an integer response with the GID\nof the group. This works by reading the /etc/group file in the image.\n\n\nYields an error if it cannot find the group or from has not been called.\n\n\nExample:\n\n\nfrom \ndebian\n\nrun \ngroupadd cabal\n\nrun \ngetent group #{getgid(\ncabal\n)}", 
            "title": "Functions"
        }, 
        {
            "location": "/user-guide/functions/#save", 
            "text": "save  saves an image with parameters:   tag : tag the image in the docker image store. This does not generate a\n  commit, like the  tag  verb does.  file : save the image to a file. The resulting file will be a bare tarball\n  with the image contents, suitable for  docker load .  type : Two options:  docker , and  oci .   Example:  Tag an image with the name \"foo\":  from  ubuntu \nsave tag:  foo   Save the ubuntu image to file after updating it:  from  ubuntu \nrun  apt-get update -qq   apt-get dist-upgrade -y \nsave file:  ubuntu-with-update.tar", 
            "title": "save"
        }, 
        {
            "location": "/user-guide/functions/#skip", 
            "text": "skip skips all layers within its block in the final produced image, which may\nbe tagged with the  -t  commandline argument or modified in an  after  clause.  Note that any other tagging or references to images built will still be\navailable with full image contents, this only affects the final output image.  WARNING : This command can cause extreme latency over TCP connections as it\nrebuilds images locally, which requires it to pull down and re-push any images.\nIt is strongly recommended you build on the host you wish to push from or use.  Example:  This will import the  debian  image, and run commands to install software\nvia  apt-get . Then it will remove the update process's layer's contents from\nthe image, removing caches and other dirt from the final image.  from  debian \n\nskip do\n  run  apt-get update \nend\n\nrun  apt-get install tmux", 
            "title": "skip"
        }, 
        {
            "location": "/user-guide/functions/#import", 
            "text": "import loads a ruby file, and then executes it as if it were a box plan. This\nis principally used to modularize build instructions between multiple builds.  Note that this will load ruby files specified anywhere on the filesystem. Use\nat your own risk. You can provide the  -o import  option to omit this function\nfrom use.  Example:  File A:  from  debian   File B imports File A and builds on it:  import  file-a.rb \nrun  ls", 
            "title": "import"
        }, 
        {
            "location": "/user-guide/functions/#getenv", 
            "text": "getenv retrieves a value from the building environment (passed in as string)\nand returns a string with the value. If no value exists, an empty string is\nreturned.  Example:  # If you set IMAGE=ceph/rbd:latest in your environment, that would be pulled\n# via the `from` statement.\nfrom getenv( IMAGE )", 
            "title": "getenv"
        }, 
        {
            "location": "/user-guide/functions/#read", 
            "text": "read takes a filename as string, reads it from the latest image in the\nevaluation and returns its data. Yields an error if the file does not exist\nor from has not been called.  read returns a string which may then be manipulated with normal string\nmanipulations in ruby.  Example:  from  debian \n# this gets the first username in your passwd file inside the debian image\nrun  echo #{read( /etc/passwd ).split( \\n ).first.split( : )[0]}", 
            "title": "read"
        }, 
        {
            "location": "/user-guide/functions/#getuid", 
            "text": "getuid, given a string username provides an integer response with the UID of\nthe user. This works by reading the /etc/passwd file in the image.  Yields an error if it cannot find the user or from has not been called.  Example:  from  debian \nrun  useradd -m -d /home/erikh -s /bin/sh erikh \nrun  id #{getuid( erikh )}", 
            "title": "getuid"
        }, 
        {
            "location": "/user-guide/functions/#getgid", 
            "text": "getgid, given a string group name provides an integer response with the GID\nof the group. This works by reading the /etc/group file in the image.  Yields an error if it cannot find the group or from has not been called.  Example:  from  debian \nrun  groupadd cabal \nrun  getent group #{getgid( cabal )}", 
            "title": "getgid"
        }
    ]
}